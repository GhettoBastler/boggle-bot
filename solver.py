#! /usr/bin/env python

import argparse
import json
import time
from string import ascii_letters


NEIGHBORS = {
    (0, 0): {(0, 1), (1, 0), (1, 1)},
    (0, 1): {(0, 0), (1, 0), (1, 1), (1, 2), (0, 2)},
    (0, 2): {(0, 1), (1, 1), (1, 2), (1, 3), (0, 3)},
    (1, 0): {(0, 0), (0, 1), (1, 1), (2, 1), (2, 0)},
    (2, 0): {(1, 0), (1, 1), (2, 1), (3, 1), (3, 0)},
    (1, 3): {(0, 3), (0, 2), (1, 2), (2, 2), (2, 3)},
    (2, 3): {(1, 3), (1, 2), (2, 2), (3, 2), (3, 3)},
    (3, 1): {(3, 0), (2, 0), (2, 1), (2, 2), (3, 2)},
    (3, 2): {(3, 1), (2, 1), (2, 2), (2, 3), (3, 3)},
    (1, 1): {(0, 0), (0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1), (2, 2)},
    (1, 2): {(0, 1), (0, 2), (0, 3), (1, 1), (1, 3), (2, 1), (2, 2), (2, 3)},
    (2, 1): {(1, 0), (1, 1), (1, 2), (2, 0), (2, 2), (3, 0), (3, 1), (3, 2)},
    (2, 2): {(1, 1), (1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2), (3, 3)},
    (0, 3): {(0, 2), (1, 2), (1, 3)},
    (3, 0): {(2, 0), (2, 1), (3, 1)},
    (3, 3): {(3, 2), (2, 2), (2, 3)},
}

ARROWS = {
    (-1, 0): '↑',
    (-1, 1): '↗',
    (0, 1): '→',
    (1, 1): '↘',
    (1, 0): '↓',
    (1, -1): '↙',
    (0, -1): '←',
    (-1, -1): '↖',
}

FG_COLORS = {
    'BLACK': '\033[30m',
    'RED': '\033[31m',
    'GREEN': '\033[32m',
    'YELLOW': '\033[33m',
    'BLUE': '\033[34m',
    'PURPLE': '\033[35m',
    'CYAN': '\033[36m',
    'WHITE': '\033[37m',
}

BG_COLORS = {
    'BLACK': '\033[40m',
    'RED': '\033[41m',
    'GREEN': '\033[42m',
    'YELLOW': '\033[43m',
    'BLUE': '\033[44m',
    'PURPLE': '\033[45m',
    'CYAN': '\033[46m',
    'WHITE': '\033[47m',
}

STYLES = {
    'BOLD': '\033[1m',
    'UNDERLINE': '\033[4m',
}

COLOR_END = '\033[0m'

# Display style
COLOR_START = STYLES['BOLD'] + BG_COLORS['PURPLE'] + FG_COLORS['WHITE']
COLOR_LABEL = FG_COLORS['PURPLE']
COLOR_ARROW = FG_COLORS['CYAN']
COLOR_WORD = FG_COLORS['CYAN']
COLOR_PLACEHOLDER = ''


def ask_for_letters():
    letters = ''
    while len(letters) < 16:
        raw_letters = input(f'Entrez les lettres ({16-len(letters)} lettres restantes) ')
        letters += ''.join(l.upper() for l in raw_letters if l in ascii_letters)
    return letters


def path_to_word(path, grid):
    res = ''
    for coord in path:
        res += grid[coord[0]][coord[1]]

    return res


def show_path(path):
    grid = []

    # Making basic grid
    for i in range(4):
        line = []
        for j in range(4):
            line.append(f'{COLOR_PLACEHOLDER}●{COLOR_END}')
            if j < 3:
                line.append(' ')
        grid.append(line)
        if i < 3:
            grid.append([' ']*7)

    # Inserting labels
    for i, coord in enumerate(path):
        y, x = coord

        if i == 0:
            label = f'{COLOR_START}1{COLOR_END}'
        else:
            label = f'{COLOR_LABEL}{str(i+1)}{COLOR_END}'

        grid[y*2][x*2] = label

    # Inserting arrows
    for a, b in zip(path, path[1:]):
        diff_y = b[0] - a[0]
        diff_x = b[1] - a[1]
        arrow = ARROWS[(diff_y, diff_x)]

        arrow_y = a[0] + b[0]
        arrow_x = a[1] + b[1]

        # Considering crossovers
        if grid[arrow_y][arrow_x] == ' ':
            grid[arrow_y][arrow_x] = f'{COLOR_ARROW}{arrow}{COLOR_END}'
        else:
            grid[arrow_y][arrow_x] = f'{COLOR_ARROW}×{COLOR_END}'

    # Printing grid
    for line in grid:
        print_line = ' '.join(line)
        print(f'{print_line}')


def tell(grid, paths, auto, delay):
    for i, path in enumerate(paths):
        word = path_to_word(path, grid)

        print(f'\n[{i+1}/{len(paths)}] {COLOR_WORD}{word}{COLOR_END}') 
        show_path(path)

        if auto:
            time.sleep(delay)
        else:
            input('Appuyez sur Entrée pour continuer...')


def search_paths(grid, tree):
    res = []
    found = set()

    queue = [[n] for n in NEIGHBORS]

    while queue:

        curr_path = queue.pop()
        possible_neighbors = [n for n in NEIGHBORS[curr_path[-1]] if n not in curr_path]

        for neighbor in possible_neighbors:

            candidate = curr_path + [neighbor]
            word = path_to_word(candidate, grid)

            if word in tree:
                if '.' in tree[word] and word not in found:
                    # Arrived at a leaf node. This is a valid word.
                    res.append(candidate)
                    found.add(word)

                queue.insert(0, candidate)
                
    return res


def get_parser():
    parser = argparse.ArgumentParser(description='Cheat at Boggle/Wordblitz')
    parser.add_argument('tree', help='a JSON file containing a word tree generated by tree_maker.py')
    parser.add_argument('-a', '--auto', action='store_true', default=False, help='show solutions automatically')
    parser.add_argument('-d', '--delay', type=float, default=1, help='How long to wait before showing the next solution (in auto mode)')

    return parser


def main():
    parser = get_parser()
    args = parser.parse_args()

    # Loading tree
    with open(args.tree) as f:
        tree = json.load(f)

    # Asking for the letters in the grid
    letters = ask_for_letters()
    grid = [letters[:4], letters[4:8], letters[8:12], letters[12:16]]

    # Displaying grid
    for line in grid:
        print(' '.join(line))

    # Searching for possible words
    t_start = time.time()
    paths = search_paths(grid, tree)
    print(f'Trouvé {len(paths)} mots en {time.time()-t_start:.3f} secondes.')

    # Displaying solutions
    paths.sort(key=len, reverse=True)
    tell(grid, paths, args.auto, args.delay)

if __name__ == '__main__':
    main()
